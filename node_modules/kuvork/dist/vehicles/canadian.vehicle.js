var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import got from 'got';
import logger from '../logger';
import { REGIONS, DEFAULT_VEHICLE_STATUS_OPTIONS } from '../constants';
import { CA_ENDPOINTS, CLIENT_ORIGIN } from '../constants/canada';
import { Vehicle } from './vehicle';
import { celciusToTempCode } from '../util';
import { parse as parseDate } from 'date-fns';
export default class CanadianVehicle extends Vehicle {
    constructor(vehicleConfig, controller) {
        super(vehicleConfig, controller);
        this.vehicleConfig = vehicleConfig;
        this.controller = controller;
        this.region = REGIONS.CA;
        this.timeOffset = -(new Date().getTimezoneOffset() / 60);
        logger.debug(`CA Vehicle ${this.vehicleConfig.id} created`);
    }
    fullStatus() {
        throw new Error('Method not implemented.');
    }
    status(input) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        return __awaiter(this, void 0, void 0, function* () {
            const statusConfig = Object.assign(Object.assign({}, DEFAULT_VEHICLE_STATUS_OPTIONS), input);
            logger.debug('Begin status request, polling car: ' + input.refresh);
            try {
                const endpoint = statusConfig.refresh ? CA_ENDPOINTS[this.userConfig.brand].remoteStatus : CA_ENDPOINTS[this.userConfig.brand].status;
                const response = yield this.request(endpoint, {});
                const vehicleStatus = response.result;
                if (response === null || response === void 0 ? void 0 : response.error) {
                    throw (_a = response === null || response === void 0 ? void 0 : response.error) === null || _a === void 0 ? void 0 : _a.errorDesc;
                }
                logger.debug(vehicleStatus);
                const parsedStatus = {
                    chassis: {
                        hoodOpen: vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.hoodOpen,
                        trunkOpen: vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.trunkOpen,
                        locked: vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.doorLock,
                        openDoors: {
                            frontRight: !!((_b = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.doorOpen) === null || _b === void 0 ? void 0 : _b.frontRight),
                            frontLeft: !!((_c = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.doorOpen) === null || _c === void 0 ? void 0 : _c.frontLeft),
                            backLeft: !!((_d = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.doorOpen) === null || _d === void 0 ? void 0 : _d.backLeft),
                            backRight: !!((_e = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.doorOpen) === null || _e === void 0 ? void 0 : _e.backRight),
                        },
                        tirePressureWarningLamp: {
                            rearLeft: !!((_f = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.tirePressureLamp) === null || _f === void 0 ? void 0 : _f.tirePressureWarningLampRearLeft),
                            frontLeft: !!((_g = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.tirePressureLamp) === null || _g === void 0 ? void 0 : _g.tirePressureWarningLampFrontLeft),
                            frontRight: !!((_h = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.tirePressureLamp) === null || _h === void 0 ? void 0 : _h.tirePressureWarningLampFrontRight),
                            rearRight: !!((_j = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.tirePressureLamp) === null || _j === void 0 ? void 0 : _j.tirePressureWarningLampRearRight),
                            all: !!((_k = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.tirePressureLamp) === null || _k === void 0 ? void 0 : _k.tirePressureWarningLampAll),
                        },
                    },
                    climate: {
                        active: vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.airCtrlOn,
                        steeringwheelHeat: !!(vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.steerWheelHeat),
                        sideMirrorHeat: false,
                        rearWindowHeat: !!(vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.sideBackWindowHeat),
                        defrost: vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.defrost,
                        temperatureSetpoint: (_l = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.airTemp) === null || _l === void 0 ? void 0 : _l.value,
                        temperatureUnit: (_m = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.airTemp) === null || _m === void 0 ? void 0 : _m.unit,
                    },
                    // TODO: fix props for parsed???
                    // Seems some of the translation would have to account for EV and ICE
                    // as they are often in different locations on the response
                    // example EV status is in lib/__mock__/canadianStatus.json
                    engine: {
                        ignition: vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.engine,
                        accessory: vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.acc,
                        range: (_o = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.dte) === null || _o === void 0 ? void 0 : _o.value,
                        charging: (_p = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.evStatus) === null || _p === void 0 ? void 0 : _p.batteryCharge,
                        batteryCharge12v: (_q = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.battery) === null || _q === void 0 ? void 0 : _q.batSoc,
                        batteryChargeHV: (_r = vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.evStatus) === null || _r === void 0 ? void 0 : _r.batteryStatus,
                    },
                    lastupdate: parseDate(vehicleStatus === null || vehicleStatus === void 0 ? void 0 : vehicleStatus.time, 'yyyyMMddHHmmSS', new Date())
                };
                this._status = statusConfig.parsed ? parsedStatus : vehicleStatus;
                return this._status;
            }
            catch (err) {
                throw err.message;
            }
        });
    }
    //////////////////////////////////////////////////////////////////////////////
    // Car commands with preauth (PIN)
    //////////////////////////////////////////////////////////////////////////////
    lock() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Begin lock request');
            try {
                const preAuth = yield this.getPreAuth();
                // assuming the API returns a bad status code for failed attempts
                yield this.request(CA_ENDPOINTS[this.userConfig.brand].lock, {}, { pAuth: preAuth });
                return 'Lock successful';
            }
            catch (err) {
                throw err.message;
            }
        });
    }
    unlock() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Begin unlock request');
            try {
                const preAuth = yield this.getPreAuth();
                yield this.request(CA_ENDPOINTS[this.userConfig.brand].unlock, {}, { pAuth: preAuth });
                return 'Unlock successful';
            }
            catch (err) {
                throw err.message;
            }
        });
    }
    /*
    airCtrl: Boolean,  // climatisation
    heating1: Boolean, // front defrost, airCtrl will be on
    defrost: Boolean,  // side mirrors & rear defrost
    airTempvalue: number | null  // temp in degrees for clim and heating 17-27
    */
    start(startConfig) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Begin startClimate request');
            try {
                const body = {
                    hvacInfo: {
                        airCtrl: ((_a = startConfig.airCtrl) !== null && _a !== void 0 ? _a : false) || ((_b = startConfig.defrost) !== null && _b !== void 0 ? _b : false) ? 1 : 0,
                        defrost: (_c = startConfig.defrost) !== null && _c !== void 0 ? _c : false,
                        // postRemoteFatcStart: 1,
                        heating1: startConfig.heating1 ? 1 : 0,
                    },
                };
                const airTemp = startConfig.airTempvalue;
                // TODO: can we use getTempCode here from util?
                if (airTemp != null) {
                    body.hvacInfo['airTemp'] = { value: celciusToTempCode(airTemp), unit: 0, hvacTempType: 1 };
                }
                else if (((_d = startConfig.airCtrl) !== null && _d !== void 0 ? _d : false) || ((_e = startConfig.defrost) !== null && _e !== void 0 ? _e : false)) {
                    throw 'air temperature should be specified';
                }
                const preAuth = yield this.getPreAuth();
                const response = yield this.request(CA_ENDPOINTS[this.userConfig.brand].start, body, { pAuth: preAuth });
                logger.debug(response);
                if (response.statusCode === 200) {
                    return 'Vehicle started!';
                }
                return 'Failed to start vehicle';
            }
            catch (err) {
                throw err.message;
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Begin stop request');
            try {
                const preAuth = yield this.getPreAuth();
                const response = yield this.request(CA_ENDPOINTS[this.userConfig.brand].stop, {
                    pAuth: preAuth,
                });
                return response;
            }
            catch (err) {
                throw 'error: ' + err;
            }
        });
    }
    // TODO: type this
    lights(withHorn = false) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Begin lights request with horn ' + withHorn);
            try {
                const preAuth = yield this.getPreAuth();
                const response = yield this.request(CA_ENDPOINTS[this.userConfig.brand].hornlight, { horn: withHorn }, { pAuth: preAuth });
                return response;
            }
            catch (err) {
                throw 'error: ' + err;
            }
        });
    }
    // TODO: @Seb to take a look at doing this
    odometer() {
        throw new Error('Method not implemented.');
    }
    location() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Begin locate request');
            try {
                const preAuth = yield this.getPreAuth();
                const response = yield this.request(CA_ENDPOINTS[this.userConfig.brand].locate, {}, { pAuth: preAuth });
                this._location = response.result;
                return this._location;
            }
            catch (err) {
                throw 'error: ' + err;
            }
        });
    }
    //////////////////////////////////////////////////////////////////////////////
    // Internal
    //////////////////////////////////////////////////////////////////////////////
    // Does this have to be done before every command?
    getPreAuth() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info('Begin pre-authentication');
            try {
                const response = yield this.request(CA_ENDPOINTS[this.userConfig.brand].verifyPin, {});
                return response.result.pAuth;
            }
            catch (err) {
                throw 'error: ' + err;
            }
        });
    }
    // TODO: not sure how to type a dynamic response
    /* eslint-disable @typescript-eslint/no-explicit-any */
    request(endpoint, body, headers = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug(`[${endpoint}] ${JSON.stringify(headers)} ${JSON.stringify(body)}`);
            // add logic for token refresh to ensure we don't use a stale token
            yield this.controller.refreshAccessToken();
            const options = {
                method: 'POST',
                json: true,
                throwHttpErrors: false,
                headers: Object.assign({ from: CLIENT_ORIGIN, language: 1, offset: this.timeOffset, accessToken: this.controller.session.accessToken, vehicleId: this.vehicleConfig.id }, headers),
                body: Object.assign({ pin: this.userConfig.pin }, body),
            };
            try {
                const response = yield got(endpoint, options);
                if (response.body.responseHeader.responseCode != 0) {
                    return response.body.responseHeader.responseDesc;
                }
                return response.body;
            }
            catch (err) {
                throw 'error: ' + err;
            }
        });
    }
}
//# sourceMappingURL=canadian.vehicle.js.map