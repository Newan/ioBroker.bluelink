var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import got from 'got';
import { CA_ENDPOINTS, CLIENT_ORIGIN } from '../constants/canada';
import CanadianVehicle from '../vehicles/canadian.vehicle';
import { SessionController } from './controller';
import logger from '../logger';
import { manageBluelinkyError } from '../tools/common.tools';
export class CanadianController extends SessionController {
    constructor(userConfig) {
        super(userConfig);
        this.vehicles = [];
        this.timeOffset = -(new Date().getTimezoneOffset() / 60);
        logger.debug('CA Controller created');
    }
    refreshAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldRefreshToken = Math.floor(Date.now() / 1000 - this.session.tokenExpiresAt) >= -10;
            logger.debug('shouldRefreshToken: ' + shouldRefreshToken.toString());
            if (this.session.refreshToken && shouldRefreshToken) {
                // TODO: someone should find the refresh token API url then we dont have to do this hack
                // the previously used CA_ENDPOINTS.verifyToken did not refresh it only provided if the token was valid
                yield this.login();
                logger.debug('Token refreshed');
                return 'Token refreshed';
            }
            logger.debug('Token not expired, no need to refresh');
            return 'Token not expired, no need to refresh';
        });
    }
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info('Begin login request');
            try {
                const response = yield this.request(CA_ENDPOINTS[this.userConfig.brand].login, {
                    loginId: this.userConfig.username,
                    password: this.userConfig.password,
                });
                logger.debug(response.result);
                this.session.accessToken = response.result.accessToken;
                this.session.refreshToken = response.result.refreshToken;
                this.session.tokenExpiresAt = Math.floor(+new Date() / 1000 + response.result.expireIn);
                return 'login good';
            }
            catch (err) {
                return 'error: ' + err;
            }
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return 'OK';
        });
    }
    getVehicles() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info('Begin getVehicleList request');
            try {
                const response = yield this.request(CA_ENDPOINTS[this.userConfig.brand].vehicleList, {});
                const data = response.result;
                if (data.vehicles === undefined) {
                    this.vehicles = [];
                    return this.vehicles;
                }
                data.vehicles.forEach(vehicle => {
                    const vehicleConfig = {
                        nickname: vehicle.nickName,
                        name: vehicle.nickName,
                        vin: vehicle.vin,
                        regDate: vehicle.enrollmentDate,
                        brandIndicator: vehicle.brandIndicator,
                        regId: vehicle.regid,
                        id: vehicle.vehicleId,
                        generation: vehicle.genType,
                    };
                    this.vehicles.push(new CanadianVehicle(vehicleConfig, this));
                });
                return this.vehicles;
            }
            catch (err) {
                logger.debug(err);
                return this.vehicles;
            }
        });
    }
    //////////////////////////////////////////////////////////////////////////////
    // Internal
    //////////////////////////////////////////////////////////////////////////////
    // TODO: not quite sure how to type this if it's dynamic?
    /* eslint-disable @typescript-eslint/no-explicit-any */
    request(endpoint, body, headers = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug(`[${endpoint}] ${JSON.stringify(headers)} ${JSON.stringify(body)}`);
            try {
                const response = yield got(endpoint, {
                    method: 'POST',
                    json: true,
                    headers: Object.assign({ from: CLIENT_ORIGIN, language: 1, offset: this.timeOffset, accessToken: this.session.accessToken }, headers),
                    body: Object.assign({}, body),
                });
                if (response.body.responseHeader.responseCode != 0) {
                    throw response.body.responseHeader.responseDesc;
                }
                return response.body;
            }
            catch (err) {
                throw manageBluelinkyError(err, 'CanadianController');
            }
        });
    }
}
//# sourceMappingURL=canadian.controller.js.map