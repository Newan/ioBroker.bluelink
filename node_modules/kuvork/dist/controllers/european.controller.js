var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { EU_CONSTANTS, EU_BASE_URL, EU_API_HOST, EU_CLIENT_ID, DEFAULT_LANGUAGE, EU_LANGUAGES } from '../constants/europe';
import * as pr from 'push-receiver';
import got from 'got';
import { ALL_ENDPOINTS } from '../constants';
import EuropeanVehicle from '../vehicles/european.vehicle';
import { SessionController } from './controller';
import logger from '../logger';
import { URLSearchParams } from 'url';
import { CookieJar } from 'tough-cookie';
import { getStamp } from '../tools/european.tools';
import { asyncMap, manageBluelinkyError, uuidV4 } from '../tools/common.tools';
export class EuropeanController extends SessionController {
    constructor(userConfig) {
        var _a;
        super(userConfig);
        this.session = {
            accessToken: undefined,
            refreshToken: undefined,
            controlToken: undefined,
            deviceId: uuidV4(),
            tokenExpiresAt: 0,
            controlTokenExpiresAt: 0,
        };
        this.vehicles = [];
        this.userConfig.language = (_a = userConfig.language) !== null && _a !== void 0 ? _a : DEFAULT_LANGUAGE;
        if (!EU_LANGUAGES.includes(this.userConfig.language)) {
            throw new Error(`The language code ${this.userConfig.language} is not managed. Only ${EU_LANGUAGES.join(', ')} are.`);
        }
        this.session.deviceId = uuidV4();
        logger.debug('EU Controller created');
    }
    refreshAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldRefreshToken = Math.floor(Date.now() / 1000 - this.session.tokenExpiresAt) >= -10;
            if (!this.session.refreshToken) {
                logger.debug('Need refresh token to refresh access token. Use login()');
                return 'Need refresh token to refresh access token. Use login()';
            }
            if (!shouldRefreshToken) {
                logger.debug('Token not expired, no need to refresh');
                return 'Token not expired, no need to refresh';
            }
            const formData = new URLSearchParams();
            formData.append('grant_type', 'refresh_token');
            formData.append('redirect_uri', 'https://www.getpostman.com/oauth2/callback'); // Oversight from Hyundai developers
            formData.append('refresh_token', this.session.refreshToken);
            try {
                const response = yield got(ALL_ENDPOINTS.EU[this.userConfig.brand].token, {
                    method: 'POST',
                    headers: {
                        'Authorization': EU_CONSTANTS[this.userConfig.brand].basicToken,
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Host': EU_API_HOST[this.userConfig.brand],
                        'Connection': 'Keep-Alive',
                        'Accept-Encoding': 'gzip',
                        'User-Agent': 'okhttp/3.10.0',
                    },
                    body: formData.toString(),
                    throwHttpErrors: false,
                });
                if (response.statusCode !== 200) {
                    logger.debug(`Refresh token failed: ${response.body}`);
                    return `Refresh token failed: ${response.body}`;
                }
                const responseBody = JSON.parse(response.body);
                this.session.accessToken = 'Bearer ' + responseBody.access_token;
                this.session.tokenExpiresAt = Math.floor(Date.now() / 1000 + responseBody.expires_in);
            }
            catch (err) {
                throw manageBluelinkyError(err, 'EuropeController.refreshAccessToken');
            }
            logger.debug('Token refreshed');
            return 'Token refreshed';
        });
    }
    enterPin() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.session.accessToken === '') {
                throw 'Token not set';
            }
            try {
                const response = yield got(`${EU_BASE_URL[this.userConfig.brand]}/api/v1/user/pin`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': this.session.accessToken,
                        'Content-Type': 'application/json',
                    },
                    body: {
                        deviceId: this.session.deviceId,
                        pin: this.userConfig.pin,
                    },
                    json: true,
                });
                this.session.controlToken = 'Bearer ' + response.body.controlToken;
                this.session.controlTokenExpiresAt = Math.floor(Date.now() / 1000 + response.body.expiresTime);
                return 'PIN entered OK, The pin is valid for 10 minutes';
            }
            catch (err) {
                throw manageBluelinkyError(err, 'EuropeController.pin');
            }
        });
    }
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // request cookie via got and store it to the cookieJar
                const cookieJar = new CookieJar();
                yield got(ALL_ENDPOINTS.EU[this.userConfig.brand].session, { cookieJar });
                logger.debug('@EuropeController.login: Initialized the auth session');
                // required by the api to set lang
                yield got(ALL_ENDPOINTS.EU[this.userConfig.brand].language, { method: 'POST', body: '{"lang":"${this.userConfig.language}"}', cookieJar });
                logger.debug(`@EuropeController.login: defined the language to ${this.userConfig.language}`);
                const authCodeResponse = yield got(ALL_ENDPOINTS.EU[this.userConfig.brand].login, {
                    method: 'POST',
                    json: true,
                    body: {
                        'email': this.userConfig.username,
                        'password': this.userConfig.password,
                    },
                    cookieJar,
                });
                let authorizationCode;
                if (authCodeResponse) {
                    const regexMatch = /code=([^&]*)/g.exec(authCodeResponse.body.redirectUrl);
                    if (regexMatch !== null) {
                        authorizationCode = regexMatch[1];
                    }
                    else {
                        throw new Error('@EuropeController.login: AuthCode was not found, you probably need to migrate your account.');
                    }
                }
                logger.debug('@EuropeController.login: Authenticated properly with user and password');
                const credentials = yield pr.register(EU_CONSTANTS[this.userConfig.brand].GCMSenderID);
                const notificationReponse = yield got(`${EU_BASE_URL[this.userConfig.brand]}/api/v1/spa/notifications/register`, {
                    method: 'POST',
                    headers: {
                        'ccsp-service-id': EU_CLIENT_ID[this.userConfig.brand],
                        'Content-Type': 'application/json;charset=UTF-8',
                        'Host': EU_API_HOST[this.userConfig.brand],
                        'Connection': 'Keep-Alive',
                        'Accept-Encoding': 'gzip',
                        'User-Agent': 'okhttp/3.10.0',
                        'Stamp': yield getStamp(this.userConfig.brand),
                    },
                    body: {
                        pushRegId: credentials.gcm.token,
                        pushType: 'GCM',
                        uuid: this.session.deviceId,
                    },
                    json: true,
                });
                if (notificationReponse) {
                    this.session.deviceId = notificationReponse.body.resMsg.deviceId;
                }
                logger.debug('@EuropeController.login: Device registered');
                const formData = new URLSearchParams();
                formData.append('grant_type', 'authorization_code');
                formData.append('redirect_uri', ALL_ENDPOINTS.EU[this.userConfig.brand].redirectUri);
                formData.append('code', authorizationCode);
                const response = yield got(ALL_ENDPOINTS.EU[this.userConfig.brand].token, {
                    method: 'POST',
                    headers: {
                        'Authorization': EU_CONSTANTS[this.userConfig.brand].basicToken,
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Host': EU_API_HOST[this.userConfig.brand],
                        'Connection': 'Keep-Alive',
                        'Accept-Encoding': 'gzip',
                        'User-Agent': 'okhttp/3.10.0',
                        'grant_type': 'authorization_code',
                        'Stamp': yield getStamp(this.userConfig.brand),
                    },
                    body: formData.toString(),
                    cookieJar,
                });
                if (response.statusCode !== 200) {
                    throw `Get token failed: ${response.body}`;
                }
                if (response) {
                    const responseBody = JSON.parse(response.body);
                    this.session.accessToken = 'Bearer ' + responseBody.access_token;
                    this.session.refreshToken = responseBody.refresh_token;
                    this.session.tokenExpiresAt = Math.floor(Date.now() / 1000 + responseBody.expires_in);
                }
                logger.debug('@EuropeController.login: Session defined properly');
                return 'Login success';
            }
            catch (err) {
                throw manageBluelinkyError(err, 'EuropeController.login');
            }
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return 'OK';
        });
    }
    getVehicles() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.session.accessToken === undefined) {
                throw 'Token not set';
            }
            try {
                const response = yield got(`${EU_BASE_URL[this.userConfig.brand]}/api/v1/spa/vehicles`, {
                    method: 'GET',
                    headers: {
                        'Authorization': this.session.accessToken,
                        'ccsp-device-id': this.session.deviceId,
                        'Stamp': yield getStamp(this.userConfig.brand),
                    },
                    json: true,
                });
                this.vehicles = yield asyncMap(response.body.resMsg.vehicles, (v) => __awaiter(this, void 0, void 0, function* () {
                    const vehicleProfileReponse = yield got(`${EU_BASE_URL[this.userConfig.brand]}/api/v1/spa/vehicles/${v.vehicleId}/profile`, {
                        method: 'GET',
                        headers: {
                            'Authorization': this.session.accessToken,
                            'ccsp-device-id': this.session.deviceId,
                            'Stamp': yield getStamp(this.userConfig.brand),
                        },
                        json: true,
                    });
                    const vehicleProfile = vehicleProfileReponse.body.resMsg;
                    const vehicleConfig = {
                        nickname: v.nickname,
                        name: v.vehicleName,
                        regDate: v.regDate,
                        brandIndicator: 'H',
                        id: v.vehicleId,
                        vin: vehicleProfile.vinInfo[0].basic.vin,
                        generation: vehicleProfile.vinInfo[0].basic.modelYear,
                    };
                    logger.debug(`@EuropeController.getVehicles: Added vehicle ${vehicleConfig.id}`);
                    return new EuropeanVehicle(vehicleConfig, this);
                }));
            }
            catch (err) {
                throw manageBluelinkyError(err, 'EuropeController.getVehicles');
            }
            return this.vehicles;
        });
    }
}
//# sourceMappingURL=european.controller.js.map